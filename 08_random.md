# Random numbers

## Objective

For many practical applications we need to use some randomness.  We look at generating random numbers in C++.

## Determinsm

Most computer programs do the same thing every time they are executed,
so they are said to be **deterministic**.  Usually, determinism is a
good thing, since we expect the same calculation to yield the same
result.  For some applications, though, we would like the
computer to be unpredictable.  Games are an obvious example.

Making a program truly **nondeterministic** turns out to be not
so easy, but there are ways to make it at least seem
nondeterministic.  One of them is to generate {pseudorandom} numbers and
use them to determine the outcome of the program.
Pseudorandom numbers
are not truly random in the mathematical sense, but 
for our purposes, they will do.

C++ provides a function called `random` that generates
pseudorandom numbers.  It is declared in the
header file `cstdlib`, which contains a variety of ``standard
library'' functions, hence the name.

The return value from `random` is an integer between `0` and 
`RAND_MAX`, where `RAND_MAX` is a large number (about 2 billion
on my computer) also defined in the header file.  Each time you call
`random` you get a different randomly-generated number.  To see a
sample, run this loop:

```c++
#include <iostream>
#include <cstdlib>
using namespace std;

int main ()
{
  for (int i = 0; i < 4; i++) {
    int x = random ();
    cout << x << endl;
  }
  return 0;
}

  
```

On my machine I got the following output:

```c++
1804289383
846930886
1681692777
1714636915
```

You will probably get something similar, but different, on yours.

Of course, we don't always want to work with gigantic integers.
More often we want to generate integers between 0 and some
upper bound.  A simple way to do that is with the modulus
operator.  For example:

```c++
  int x = random ();
  int y = x % upperBound;
```

Since `y` is the remainder when `x` is divided by
`upperBound`, the only possible values for `y`
are between 0 and `upperBound - 1`, including both
end points.  Keep in mind, though, that `y` will never
be equal to `upperBound`.

It is also frequently useful to generate random floating-point values.
A common way to do that is by dividing by `RAND_MAX`.  For
example:

```c++
  int x = random ();
  double y = double(x) / RAND_MAX;
```

This code sets `y` to a random value between 0.0 and 1.0,
including both end points.  As an exercise, you might want to
think about how to generate a random floating-point value in
a given range; for example, between 100.0 and 200.0.

## Statistics

The numbers generated by `random` are supposed to be distributed
uniformly.  That means that each value in the range should be
equally likely.  If we count the number of times each value appears,
it should be roughly the same for all values, provided that we
generate a large number of values.

In the next few sections, we will write programs that generate
a sequence of random numbers and check whether this property
holds true.

### Vector of random numbers

The first step is to generate a large number of random values
and store them in a vector.  By ``large number,'' of course,
I mean 20.  It's always a good idea to start with a manageable
number, to help with debugging, and then increase it later.

The following function takes a single argument, the size of
the vector.  It allocates a new vector of `int`s, 
and fills it with random values between 0 and `upperBound-1`.

```c++
vector<int> randomVector (int n, int upperBound) {
  vector<int> vec (n);
  for (int i = 0; i<vec.size(); i++) {
    vec[i] = random () % upperBound;
  }
  return vec;
}
```

The return type is `vector<int>`, which means that
this function returns a vector of integers.
To test this function, it is convenient to have a function that
outputs the contents of a vector.

```c++
void printVector (const vector<int>& vec) {
  for (int i: vec) {
    cout << i << " ";
  }
}
```

Notice that it is legal to pass `vector`s by reference.
In fact it is quite common, since it makes it unnecessary to
copy the vector.  Since `printVector` does not modify the
vector, we declare the parameter `const`.

The following code generates a vector and outputs it:

```c++
  int numValues = 20;
  int upperBound = 10;
  vector<int> vector = randomVector (numValues, upperBound);
  printVector (vector);
```

On my machine the output is

```c++
3 6 7 5 3 5 6 2 9 1 2 7 0 9 3 6 0 6 2 6 
```

which is pretty random-looking.  Your results may differ.

If these numbers are really random,
we expect each digit to appear the same number of times---twice
each.  In fact, the number 6 appears five times, and the numbers 4
and 8 never appear at all.

Do these results mean the values are not really uniform?  It's
hard to tell.  With so few values, the chances are slim
that we would get exactly what we expect.  But as the number
of values increases, the outcome should be more predictable.

To test this theory, we'll write some programs that count the
number of times each value appears, and then see what happens
when we increase `numValues`.

### Counting

A good approach to problems like this is to think of simple functions
that are easy to write, and that might turn out to be useful.  Then
you can combine them into a solution.  This approach is sometimes
called **bottom-up design**.  Of course, it is not easy to
know ahead of time which functions are likely to be useful, but as you
gain experience you will have a better idea.

Also, it is not always obvious what sort of things are easy to write,
but a good approach is to look for subproblems that fit a pattern you
have seen before.

Back in Section {#loopcount} we looked at a loop that traversed a
string and counted the number of times a given letter appeared.  You
can think of this program as an example of a pattern called ``traverse
and count.''  The elements of this pattern are:

  * A set or container that can be traversed, like a string
or a vector.
  * A test that you can apply to each element in the container.
  * A counter that keeps track of how many elements pass
the test.

In this case, I have a function in mind called `howMany` that
counts the number of elements in a vector that equal a given value.
The parameters are the vector and the integer value we are looking
for.  The return value is the number of times the value appears.

```c++
int howMany (const vector<int>& vec, int value) {
  int count = 0;
  for (int i: vec) {
    if (i == value) {
      count++;
    }
  }
  return count;
}
```


### Checking the other values

`howMany` only counts the occurrences of a particular value, and
we are interested in seeing how many times each value appears.
We can solve that problem with a loop:

```c++
  int numValues = 20;
  int upperBound = 10;
  vector<int> vector = randomVector (numValues, upperBound);

  cout << "value\thowMany";

  for (int i = 0; i<upperBound; i++) {
    cout << i << '\t' << howMany (vector, i) << endl;
  }
```

Notice that it is legal to declare a variable inside a `for`
statement.  This syntax is sometimes convenient, but you should
be aware that a variable declared inside a loop only exists
inside the loop.  If you try to refer to `i` later, you
will get a compiler error.

This code uses the loop variable as an argument to
`howMany`, in order to check each value between 0 and 9,
in order.  The result is:

```c++
value   howMany
0       2
1       1
2       3
3       3
4       0
5       2
6       5
7       2
8       0
9       2
```

Again, it is hard to tell if the digits are really appearing
equally often.  If we increase `numValues` to 100,000 we
get the following:

```c++
value   howMany
0       10130
1       10072
2       9990
3       9842
4       10174
5       9930
6       10059
7       9954
8       9891
9       9958
```

In each case, the number of appearances is within about 1% of
the expected value (10,000), so we conclude that the random
numbers are probably uniform.

### A histogram

It is often useful to take the data from the previous tables
and store them for later access, rather than just print them.
What we need is a way to store 10 integers.  We could create
10 integer variables with names like `howManyOnes`,
`howManyTwos`, etc.  But that would require a lot of
typing, and it would be a real pain later if we decided to
change the range of values.

A better solution is to use a vector with size 10.  That
way we can create all ten storage locations at once and we
can access them using indices, rather than ten different names.
Here's how:

```c++
  int numValues = 100000;
  int upperBound = 10;
  vector<int> vector = randomVector (numValues, upperBound);
  vector<int> histogram (upperBound);

  for (int i = 0; i<upperBound; i++) {
    int count = howMany (vector, i);
    histogram[i] = count;
  }
```

I called the vector `histogram` because that's
a statistical term for a vector of numbers that counts the
number of appearances of a range of values.

The tricky thing here is that I am using the loop variable
in two different ways.  First, it is an argument to {\tt howMany},
specifying which value I am interested in.  Second, it is
an index into the histogram, specifying which location I should
store the result in.

### A single-pass solution

Although this code works, it is not as efficient as it could
be.  Every time it calls `howMany`, it traverses the
entire vector.  In this example we have to traverse the
vector ten times!

It would be better to make a single pass through the vector.
For each value in the vector we could find the corresponding
counter and increment it.  In other words, we can use the
value from the vector as an index into the histogram.  Here's
what that looks like:

```c++
  vector<int> histogram (upperBound, 0);

  for (int i = 0; i<numValues; i++) {
    int index = vector[i];
    histogram[index]++;
  }
```

The first line initializes the elements of the histogram to
zeroes.  That way, when we use the increment
operator (`++`) inside the loop, we know we are starting from zero.
Forgetting to initialize counters is a common error.

As an exercise, encapsulate this code in a function called {\tt
histogram} that takes a vector and the range of values in the vector
(in this case 0 through 10), and that returns a histogram of the
values in the vector.

## Random seeds

If you have run the code in this chapter a few times, you might
have noticed that you are getting the same _random_ values
every time.  That's not very random!

One of the properties of pseudorandom number generators is that
if they start from the same place they will generate
the same sequence of values.  The starting place is called
a **seed**; by default, C++ uses
the same seed every time you run the program.

While you are debugging, it is often helpful to
see the same sequence over and over.  That way, when you make
a change to the program you can compare the output before and
after the change.

If you want to choose a different seed for the random number
generator, you can use the `srand` function.  It takes
a single argument, which is an integer between 0 and `RAND\_MAX`.

## What we can do now

We can now create random numbers:

```c++
#include <iostream>
#include <cstdlib>

int dice_roll() {
  int number = (random() % 6) + 1;
  return number;
}

int main() {
  std::cout << "You roll a " << dice_roll() << std::endl;
  return 0;
}
```