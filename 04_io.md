
# Input and Output

## Objective

We look at prompting users for input and processing that input.

## Output

We have already seen how to output to the console.  This was introduced in our "Hello, world!" program.  Output to the console directs `string`s and `int`s to `cout`.  This is useful to, for example, print current exchange rates to the screen:

```c++
#include <iostream>

void print_fjd() {
  std::cout << "FJD$" << 1 << " is EUR" << 0.4076 << std::endl;
}

void print_vatu() {
  std::cout << 1 << "VT is EUR" << 0.0076 << std::endl;
}

void print_sat() {
  std::cout << "SAT$" << 1 << " is EUR" << 0.33143 << std::endl;
}

int main() {
  print_fjd();
  print_vatu();
  print_sat();
  return 0;
}
```

We could also have structured this program as:

```c++
#include <iostream>

void print_with_pre_symbol(
     std::string symbol, float eur_value ) {
  std::cout << symbol << 1;
  std::cout << " is EUR" << eur_value << std::endl;
}

void print_with_post_symbol(
     std::string symbol , float eur_value ) {
  std::cout << 1 << symbol;
  std::cout << " is EUR" << eur_value << std::endl;
}

int main() {
  print_with_pre_symbol("FJD$", 0.4076);
  print_with_post_symbol("VT", 0.0076);
  print_with_pre_symbol("SAT$", 0.33143);
  return 0;
}
```

In fact there are an infinite number of ways of writing the same program[^copying].  The first version of our currency printing function is arguably easier to read.  The second version is arguably easier to extend.  As a rule-of-thumb I prefer ease of reading over ease of extension.  The logic here is that you _will_ have to read your own code it's only a possibility that you might have to extend it.  In any case, if we need to extend our functions it's easy to rewrite them then.

[^copying]: This is one of the reasons that grumpy professors suspect plagiarism when two students hand up code with the same structure having only different variable and function names!

We can also print how many Euro we might get for FJD$100:

```cpp
#include <iostream>

int main() {
  float fjd_value = 100;
  float eur_value = fjd_value * 0.4076;

  std::cout << "FJD$" << fjd_value << " is worth EUR" << eur_value << std::endl;
  return 0;
}
```

But every time we want to find out how many hard earned FJD we need to convert into holiday money we'd have to modify the source code.  This makes the program _very_ difficult to use.  Surely there must be some way of taking that value in from the user?

## Input

We've done console output and you've seen how it's not like the nice UIs you find on your phone.  Console input is going to be similarly clunky.  The only advantage is that it is easier to write the code.  The major disadvantage is that this simply isn't how we write programs intended for normal users to use.  It follows that you are probably not used to this mode of input and your mental model of a computer doesn't fit with console input.  Let's just stick with it for the moment though.

To read in an integer from the console -- which is _almost always_ connected to a keyboard -- we use the `istream` operator denoted `>>` i.e. the opposite direction of the `ostream` operator.  Like `cout`, the console input exists in the `std` namespace so its full name is `std::cin`.

```c++
#include <iostream>

int main() {
  int fjd_value;
  std::cout << "How many FJD to convert to EUR? ";
  std::cin >> fjd_value;
  std::cout << "You have chosen to convert FJD$"  << fjd_value << std::endl;
  return 0;
}
```

If we wanted to read in a `string` rather than an `int` then we would `>>` into a `string` shaped hole:

```c++
#include <iostream>

int main() {
  std::string currency;
  std::cout << "What is your favourite currency? ";
  std::cin >> currency
  std::cout << "Your favourite currency is " << currency << std::endl;
```

That seems straightforward! To read in an `int` we `std::cin >>` into an `int` variable.  To do the same for `string` we `std::cin >>` into a `string` variable.  What happens though if you type the character 'a' as an input for an `int`?

It's useful to write yourself a suite of input functions, such as:

```c++
int get_int() {
  int x;
  std::cin >> x;
  return x;
}
```

Again, we apply the rule-of-thumb to write small functions.  This will serve us very well in future chapters.

## Testing Input

Here be dragons!  Any time you ask a user to do something, they **will** do something you have not previously considered.  Remember they're a creative bunch out there.  We can't yet write code that tests the `get_int()` function from above.  But recall another rule-of-thumb about having three values you expect to work and three values you don't expect to work.  You can document these values in a comment!

```c++
/** Gets an `int` from cin.
 *
 *  | Expected Input    | Result         |
 *  |-------------------|----------------|
 *  |   -1              | -1 is returned |
 *  |   0               |  0 is returned |
 *  |   1               |  1 is returned |
 *  |   'x'             |  unknown       |
 *  | "three"           |  unknown       |
 *  |  "" (empty input) |  unknown       |
 */
int get_int() {
  int x;
  std::cin >> x;
  return x;
}
```

This is good documentation for the poor programmer who has to come along later and use your code.  This poor programmer is often you! Just a few weeks later after you've already forgotten the details of how the function works.  Your documentation can help yourself.  I will often put a `FIXME` beside the inputs with unknown results.  This encourages me to go back later and ensure that the code only ever returns valid `int`s.

We've uncovered a huge gap in our knowledge.  Though we can now take in some input, we don't know how to check if the input is valid or not.  It turns out that checking conditions is a useful thing to be able to do.  We will study conditionals in the next chapter.

## What we can now do

We can now read input values from the console.

```c++

int read_int() {
  int val;
  std::cin >> val;
  std::cout << "You input the value " << val << std::endl;
}
```
